use anyhow::{Context, Result};
use std::fs;
use std::path::PathBuf;
use vibe_graph_core::{LayoutStrategy, SourceCodeGraph};
use vibe_graph_ops::ArchitectFactory;

pub fn execute(
    input: &PathBuf,
    output: &Option<PathBuf>,
    temp: bool,
    strategy: &str,
    width: Option<usize>,
    group_by_row: bool,
    dry_run: bool,
) -> Result<()> {
    // 1. Determine Output Directory
    let (output_path, is_temp) = if temp {
        let temp_dir = std::env::temp_dir().join(format!("vibe-graph-architect-{}", uuid::Uuid::new_v4()));
        (temp_dir, true)
    } else {
        (output.clone().unwrap_or_else(|| PathBuf::from(".")), false)
    };

    // 1b. Load the input graph
    let content = fs::read_to_string(input).context("Failed to read input graph")?;
    let logical_graph: SourceCodeGraph = serde_json::from_str(&content).context("Failed to parse input graph")?;

    println!("üìä Loaded graph with {} nodes and {} edges", logical_graph.node_count(), logical_graph.edge_count());

    // 2. Determine Strategy
    let layout_strategy = match strategy.to_lowercase().as_str() {
        "lattice" => LayoutStrategy::Lattice {
            width: width.unwrap_or(10), // Default width 10 if not provided
            group_by_row,
        },
        "flat" => LayoutStrategy::Flat,
        "preserve" | "direct" => LayoutStrategy::Preserve,
        _ => LayoutStrategy::Flat,
    };

    println!("üèóÔ∏è  Applying strategy: {:?}", layout_strategy);

    // 3. Run Architect
    let architect = ArchitectFactory::create(layout_strategy, &output_path);
    let proposed_graph = architect.architect(&logical_graph)?;

    println!("‚úÖ Architecture proposed:");
    println!("   Nodes: {}", proposed_graph.node_count());
    println!("   Edges: {}", proposed_graph.edge_count());

    // 4. Visualize / Dry Run
    if dry_run {
        println!("\nProposed Structure:");
        print_tree(&proposed_graph, &output_path);
        if is_temp {
             println!("\n(Would write to temporary directory: {})", output_path.display());
        }
        return Ok(());
    }

    // 5. Materialize (Write to disk)
    println!("\nüíæ Materializing to {}...", output_path.display());
    
    // Create root if it doesn't exist
    fs::create_dir_all(&output_path)?;

    for node in &proposed_graph.nodes {
        // We only care about creating the file/folder structure
        let path_str = node.metadata.get("path").context("Node missing path metadata")?;
        let path = PathBuf::from(path_str);
        
        match node.kind {
            vibe_graph_core::GraphNodeKind::Directory => {
                if !path.exists() {
                     fs::create_dir_all(&path)?;
                     println!("  + Dir:  {}", path.display());
                }
            }
            vibe_graph_core::GraphNodeKind::File | vibe_graph_core::GraphNodeKind::Module => {
                // Ensure parent exists
                if let Some(parent) = path.parent() {
                    fs::create_dir_all(parent)?;
                }
                if !path.exists() {
                    fs::write(&path, format!("// Generated by Vibe-Graph Architect\n// Node: {}\n", node.name))?;
                    println!("  + File: {}", path.display());
                }
            }
            _ => {}
        }
    }
    
    println!("Done.");
    
    if is_temp {
        println!("\nüìç Output available at: {}", output_path.display());
    }

    Ok(())
}

fn print_tree(graph: &SourceCodeGraph, root_path: &PathBuf) {
    // A simple tree printer
    // 1. Find all nodes that are contained by root (or effectively top level)
    // For this simple implementation, just sort by path and print
    
    let mut paths: Vec<String> = graph.nodes.iter()
        .filter_map(|n| n.metadata.get("path").cloned())
        .collect();
    paths.sort();

    for p in paths {
        if let Ok(rel) = PathBuf::from(&p).strip_prefix(root_path) {
             println!("  {}", rel.display());
        } else {
             println!("  {}", p);
        }
    }
}
